"""
This type stub file was generated by pyright.
"""

from . import widgets
from .fields import Field

logger = ...

def get_related_model(field): ...

class ResourceOptions:
    """
    The inner Meta class allows for class-level configuration of how the
    Resource should behave. The following options are available:
    """

    model = ...
    fields = ...
    exclude = ...
    instance_loader_class = ...
    import_id_fields = ...
    export_order = ...
    widgets = ...
    use_transactions = ...
    skip_unchanged = ...
    report_skipped = ...
    clean_model_instances = ...
    chunk_size = ...
    skip_diff = ...
    skip_html_diff = ...
    use_bulk = ...
    batch_size = ...
    force_init_instance = ...
    using_db = ...

class DeclarativeMetaclass(type):
    def __new__(cls, name, bases, attrs): ...

class Diff:
    def __init__(self, resource, instance, new) -> None: ...
    def compare_with(self, resource, instance, dry_run=...): ...
    def as_html(self): ...

class Resource(metaclass=DeclarativeMetaclass):
    """
    Resource defines how objects are mapped to their import and export
    representations and handle importing and exporting data.
    """

    def __init__(self) -> None: ...
    @classmethod
    def get_result_class(self):  # -> Type[Result]:
        """
        Returns the class used to store the result of an import.
        """
        ...
    @classmethod
    def get_row_result_class(self):  # -> Type[RowResult]:
        """
        Returns the class used to store the result of a row import.
        """
        ...
    @classmethod
    def get_error_result_class(self):  # -> Type[Error]:
        """
        Returns the class used to store an error resulting from an import.
        """
        ...
    @classmethod
    def get_diff_class(self):  # -> Type[Diff]:
        """
        Returns the class used to display the diff for an imported instance.
        """
        ...
    def get_db_connection_name(self): ...
    def get_use_transactions(self): ...
    def get_chunk_size(self): ...
    def get_fields(self, **kwargs):  # -> list[Unknown]:
        """
        Returns fields sorted according to
        :attr:`~import_export.resources.ResourceOptions.export_order`.
        """
        ...
    def get_field_name(self, field):
        """
        Returns the field name for a given field.
        """
        ...
    def init_instance(self, row=...):
        """
        Initializes an object. Implemented in
        :meth:`import_export.resources.ModelResource.init_instance`.
        """
        ...
    def get_instance(self, instance_loader, row):  # -> None:
        """
        If all 'import_id_fields' are present in the dataset, calls
        the :doc:`InstanceLoader <api_instance_loaders>`. Otherwise,
        returns `None`.
        """
        ...
    def get_or_init_instance(
        self, instance_loader, row
    ):  # -> tuple[Unknown, Literal[False]] | tuple[Unknown, Literal[True]]:
        """
        Either fetches an already existing instance or initializes a new one.
        """
        ...
    def get_import_id_fields(self):
        """ """
        ...
    def get_bulk_update_fields(self):  # -> list[Unknown]:
        """
        Returns the fields to be included in calls to bulk_update().
        ``import_id_fields`` are removed because `id` fields cannot be supplied to bulk_update().
        """
        ...
    def bulk_create(
        self, using_transactions, dry_run, raise_errors, batch_size=...
    ):  # -> None:
        """
        Creates objects by calling ``bulk_create``.
        """
        ...
    def bulk_update(
        self, using_transactions, dry_run, raise_errors, batch_size=...
    ):  # -> None:
        """
        Updates objects by calling ``bulk_update``.
        """
        ...
    def bulk_delete(self, using_transactions, dry_run, raise_errors):  # -> None:
        """
        Deletes objects by filtering on a list of instances to be deleted,
        then calling ``delete()`` on the entire queryset.
        """
        ...
    def validate_instance(
        self, instance, import_validation_errors=..., validate_unique=...
    ):  # -> None:
        """
        Takes any validation errors that were raised by
        :meth:`~import_export.resources.Resource.import_obj`, and combines them
        with validation errors raised by the instance's ``full_clean()``
        method. The combined errors are then re-raised as single, multi-field
        ValidationError.

        If the ``clean_model_instances`` option is False, the instances's
        ``full_clean()`` method is not called, and only the errors raised by
        ``import_obj()`` are re-raised.
        """
        ...
    def save_instance(self, instance, using_transactions=..., dry_run=...):  # -> None:
        """
        Takes care of saving the object to the database.

        Objects can be created in bulk if ``use_bulk`` is enabled.
        """
        ...
    def before_save_instance(self, instance, using_transactions, dry_run):  # -> None:
        """
        Override to add additional logic. Does nothing by default.
        """
        ...
    def after_save_instance(self, instance, using_transactions, dry_run):  # -> None:
        """
        Override to add additional logic. Does nothing by default.
        """
        ...
    def delete_instance(self, instance, using_transactions=..., dry_run=...):  # -> None:
        """
        Calls :meth:`instance.delete` as long as ``dry_run`` is not set.
        If ``use_bulk`` then instances are appended to a list for bulk import.
        """
        ...
    def before_delete_instance(self, instance, dry_run):  # -> None:
        """
        Override to add additional logic. Does nothing by default.
        """
        ...
    def after_delete_instance(self, instance, dry_run):  # -> None:
        """
        Override to add additional logic. Does nothing by default.
        """
        ...
    def import_field(self, field, obj, data, is_m2m=..., **kwargs):  # -> None:
        """
        Calls :meth:`import_export.fields.Field.save` if ``Field.attribute``
        is specified, and ``Field.column_name`` is found in ``data``.
        """
        ...
    def get_import_fields(self): ...
    def import_obj(self, obj, data, dry_run, **kwargs):  # -> None:
        """
        Traverses every field in this Resource and calls
        :meth:`~import_export.resources.Resource.import_field`. If
        ``import_field()`` results in a ``ValueError`` being raised for
        one of more fields, those errors are captured and reraised as a single,
        multi-field ValidationError."""
        ...
    def save_m2m(self, obj, data, using_transactions, dry_run):  # -> None:
        """
        Saves m2m fields.

        Model instance need to have a primary key value before
        a many-to-many relationship can be used.
        """
        ...
    def for_delete(self, row, instance):  # -> Literal[False]:
        """
        Returns ``True`` if ``row`` importing should delete instance.

        Default implementation returns ``False``.
        Override this method to handle deletion.
        """
        ...
    def skip_row(self, instance, original):  # -> bool:
        """
        Returns ``True`` if ``row`` importing should be skipped.

        Default implementation returns ``False`` unless skip_unchanged == True
        and skip_diff == False.

        If skip_diff is True, then no comparisons can be made because ``original``
        will be None.

        When left unspecified, skip_diff and skip_unchanged both default to ``False``,
        and rows are never skipped.

        Override this method to handle skipping rows meeting certain
        conditions.

        Use ``super`` if you want to preserve default handling while overriding
        ::
            class YourResource(ModelResource):
                def skip_row(self, instance, original):
                    # Add code here
                    return super(YourResource, self).skip_row(instance, original)

        """
        ...
    def get_diff_headers(self):  # -> list[Any]:
        """
        Diff representation headers.
        """
        ...
    def before_import(self, dataset, using_transactions, dry_run, **kwargs):  # -> None:
        """
        Override to add additional logic. Does nothing by default.
        """
        ...
    def after_import(
        self, dataset, result, using_transactions, dry_run, **kwargs
    ):  # -> None:
        """
        Override to add additional logic. Does nothing by default.
        """
        ...
    def before_import_row(self, row, row_number=..., **kwargs):  # -> None:
        """
        Override to add additional logic. Does nothing by default.
        """
        ...
    def after_import_row(self, row, row_result, row_number=..., **kwargs):  # -> None:
        """
        Override to add additional logic. Does nothing by default.
        """
        ...
    def after_import_instance(self, instance, new, row_number=..., **kwargs):  # -> None:
        """
        Override to add additional logic. Does nothing by default.
        """
        ...
    def import_row(
        self,
        row,
        instance_loader,
        using_transactions=...,
        dry_run=...,
        raise_errors=...,
        **kwargs
    ):
        """
        Imports data from ``tablib.Dataset``. Refer to :doc:`import_workflow`
        for a more complete description of the whole import process.

        :param row: A ``dict`` of the row to import

        :param instance_loader: The instance loader to be used to load the row

        :param using_transactions: If ``using_transactions`` is set, a transaction
            is being used to wrap the import

        :param dry_run: If ``dry_run`` is set, or error occurs, transaction
            will be rolled back.
        """
        ...
    def import_data(
        self,
        dataset,
        dry_run=...,
        raise_errors=...,
        use_transactions=...,
        collect_failed_rows=...,
        rollback_on_validation_errors=...,
        **kwargs
    ):  # -> Result:
        """
        Imports data from ``tablib.Dataset``. Refer to :doc:`import_workflow`
        for a more complete description of the whole import process.

        :param dataset: A ``tablib.Dataset``

        :param raise_errors: Whether errors should be printed to the end user
            or raised regularly.

        :param use_transactions: If ``True`` the import process will be processed
            inside a transaction.

        :param collect_failed_rows: If ``True`` the import process will collect
            failed rows.

        :param rollback_on_validation_errors: If both ``use_transactions`` and ``rollback_on_validation_errors``
            are set to ``True``, the import process will be rolled back in case of ValidationError.

        :param dry_run: If ``dry_run`` is set, or an error occurs, if a transaction
            is being used, it will be rolled back.
        """
        ...
    def import_data_inner(
        self,
        dataset,
        dry_run,
        raise_errors,
        using_transactions,
        collect_failed_rows,
        rollback_on_validation_errors=...,
        **kwargs
    ): ...
    def get_export_order(self): ...
    def before_export(self, queryset, *args, **kwargs):  # -> None:
        """
        Override to add additional logic. Does nothing by default.
        """
        ...
    def after_export(self, queryset, data, *args, **kwargs):  # -> None:
        """
        Override to add additional logic. Does nothing by default.
        """
        ...
    def export_field(self, field, obj): ...
    def get_export_fields(self): ...
    def export_resource(self, obj): ...
    def get_export_headers(self): ...
    def get_user_visible_headers(self): ...
    def get_user_visible_fields(self): ...
    def iter_queryset(self, queryset): ...
    def export(self, queryset=..., *args, **kwargs):  # -> Dataset:
        """
        Exports a resource.
        """
        ...

class ModelDeclarativeMetaclass(DeclarativeMetaclass):
    def __new__(cls, name, bases, attrs): ...

class ModelResource(Resource, metaclass=ModelDeclarativeMetaclass):
    """
    ModelResource is Resource subclass for handling Django models.
    """

    DEFAULT_RESOURCE_FIELD = Field
    WIDGETS_MAP = ...
    @classmethod
    def get_m2m_widget(cls, field):  # -> partial[ManyToManyWidget]:
        """
        Prepare widget for m2m field
        """
        ...
    @classmethod
    def get_fk_widget(cls, field):  # -> partial[ForeignKeyWidget]:
        """
        Prepare widget for fk and o2o fields
        """
        ...
    @classmethod
    def widget_from_django_field(
        cls, f, default=...
    ):  # -> Type[SimpleArrayWidget] | Any | Type[DecimalWidget] | Type[DateTimeWidget] | Type[DateWidget] | Type[TimeWidget] | Type[DurationWidget] | Type[FloatWidget] | Type[IntegerWidget] | Type[BooleanWidget] | Type[JSONWidget] | Type[Widget]:
        """
        Returns the widget that would likely be associated with each
        Django type.

        Includes mapping of Postgres Array and JSON fields. In the case that
        psycopg2 is not installed, we consume the error and process the field
        regardless.
        """
        ...
    @classmethod
    def widget_kwargs_for_field(self, field_name):  # -> dict[Unknown, Unknown]:
        """
        Returns widget kwargs for given field_name.
        """
        ...
    @classmethod
    def field_from_django_field(
        cls, field_name, django_field, readonly
    ):  # -> DEFAULT_RESOURCE_FIELD:
        """
        Returns a Resource Field instance for the given Django model field.
        """
        ...
    def get_queryset(self):
        """
        Returns a queryset of all objects for this model. Override this if you
        want to limit the returned queryset.
        """
        ...
    def init_instance(self, row=...):
        """
        Initializes a new Django model.
        """
        ...
    def after_import(
        self, dataset, result, using_transactions, dry_run, **kwargs
    ):  # -> None:
        """
        Reset the SQL sequences after new objects are imported
        """
        ...

def modelresource_factory(
    model, resource_class=...
):  # -> Type[__class_ModelDeclarativeMetaclass]:
    """
    Factory for creating ``ModelResource`` class for given Django model.
    """
    ...
