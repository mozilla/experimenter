"""
This type stub file was generated by pyright.
"""

"""Function signature objects for callables
Back port of Python 3.3's function signature tools from the inspect module,
modified to be compatible with Python 2.7 and 3.2+.
"""
__version__ = ...
__all__ = ["BoundArguments", "Parameter", "Signature", "signature"]
_WrapperDescriptor = ...
_MethodWrapper = ...
_NonUserDefinedCallables = ...

def formatannotation(annotation, base_module=...): ...
def signature(obj):  # -> Signature:
    """Get a signature object for the passed callable."""
    ...

class _void:
    """A private marker - used in Parameter & Signature"""

    ...

class _empty: ...

class _ParameterKind(int):
    def __new__(self, *args, **kwargs): ...
    def __str__(self) -> str: ...
    def __repr__(self): ...

_POSITIONAL_ONLY = ...
_POSITIONAL_OR_KEYWORD = ...
_VAR_POSITIONAL = ...
_KEYWORD_ONLY = ...
_VAR_KEYWORD = ...

class Parameter:
    """Represents a parameter in a function signature.
    Has the following public attributes:
    * name : str
        The name of the parameter as a string.
    * default : object
        The default value for the parameter if specified.  If the
        parameter has no default value, this attribute is not set.
    * annotation
        The annotation for the parameter if specified.  If the
        parameter has no annotation, this attribute is not set.
    * kind : str
        Describes how argument values are bound to the parameter.
        Possible values: `Parameter.POSITIONAL_ONLY`,
        `Parameter.POSITIONAL_OR_KEYWORD`, `Parameter.VAR_POSITIONAL`,
        `Parameter.KEYWORD_ONLY`, `Parameter.VAR_KEYWORD`.
    """

    __slots__ = ...
    POSITIONAL_ONLY = ...
    POSITIONAL_OR_KEYWORD = ...
    VAR_POSITIONAL = ...
    KEYWORD_ONLY = ...
    VAR_KEYWORD = ...
    empty = _empty
    def __init__(
        self, name, kind, default=..., annotation=..., _partial_kwarg=...
    ) -> None: ...
    @property
    def name(self): ...
    @property
    def default(self): ...
    @property
    def annotation(self): ...
    @property
    def kind(self): ...
    def replace(
        self, name=..., kind=..., annotation=..., default=..., _partial_kwarg=...
    ):  # -> Self@Parameter:
        """Creates a customized copy of the Parameter."""
        ...
    def __str__(self) -> str: ...
    def __repr__(self): ...
    def __hash__(self) -> int: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...

class BoundArguments:
    """Result of `Signature.bind` call.  Holds the mapping of arguments
    to the function's parameters.
    Has the following public attributes:
    * arguments : OrderedDict
        An ordered mutable mapping of parameters' names to arguments' values.
        Does not contain arguments' default values.
    * signature : Signature
        The Signature object that created this instance.
    * args : tuple
        Tuple of positional arguments values.
    * kwargs : dict
        Dict of keyword arguments values.
    """

    def __init__(self, signature, arguments) -> None: ...
    @property
    def signature(self): ...
    @property
    def args(self): ...
    @property
    def kwargs(self): ...
    def __hash__(self) -> int: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...

class Signature:
    """A Signature object represents the overall signature of a function.
    It stores a Parameter object for each parameter accepted by the
    function, as well as information specific to the function itself.
    A Signature object has the following public attributes and methods:
    * parameters : OrderedDict
        An ordered mapping of parameters' names to the corresponding
        Parameter objects (keyword-only arguments are in the same order
        as listed in `code.co_varnames`).
    * return_annotation : object
        The annotation for the return type of the function if specified.
        If the function has no annotation for its return type, this
        attribute is not set.
    * bind(*args, **kwargs) -> BoundArguments
        Creates a mapping from positional and keyword arguments to
        parameters.
    * bind_partial(*args, **kwargs) -> BoundArguments
        Creates a partial mapping from positional and keyword arguments
        to parameters (simulating 'functools.partial' behavior.)
    """

    __slots__ = ...
    _parameter_cls = Parameter
    _bound_arguments_cls = BoundArguments
    empty = _empty
    def __init__(
        self, parameters=..., return_annotation=..., __validate_parameters__=...
    ) -> None:
        """Constructs Signature from the given list of Parameter
        objects and 'return_annotation'.  All arguments are optional.
        """
        ...
    @classmethod
    def from_function(cls, func):  # -> Self@Signature:
        """Constructs Signature for the given python function"""
        ...
    @property
    def parameters(self): ...
    @property
    def return_annotation(self): ...
    def replace(self, parameters=..., return_annotation=...):  # -> Self@Signature:
        """Creates a customized copy of the Signature.
        Pass 'parameters' and/or 'return_annotation' arguments
        to override them in the new copy.
        """
        ...
    def __hash__(self) -> int: ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def bind(self, *args, **kwargs):  # -> _bound_arguments_cls:
        """Get a BoundArguments object, that maps the passed `args`
        and `kwargs` to the function's signature.  Raises `TypeError`
        if the passed arguments can not be bound.
        """
        ...
    def bind_partial(self, *args, **kwargs):  # -> _bound_arguments_cls:
        """Get a BoundArguments object, that partially maps the
        passed `args` and `kwargs` to the function's signature.
        Raises `TypeError` if the passed arguments can not be bound.
        """
        ...
    def __str__(self) -> str: ...
