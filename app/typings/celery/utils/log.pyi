"""
This type stub file was generated by pyright.
"""

import logging
from contextlib import contextmanager
from typing import AnyStr, Sequence

"""Logging utilities."""
__all__ = (
    "ColorFormatter",
    "LoggingProxy",
    "base_logger",
    "set_in_sighandler",
    "in_sighandler",
    "get_logger",
    "get_task_logger",
    "mlevel",
    "get_multiprocessing_logger",
    "reset_multiprocessing_logger",
    "LOG_LEVELS",
)
_process_aware = ...
_in_sighandler = ...
MP_LOG = ...
RESERVED_LOGGER_NAMES = ...
base_logger = ...

def set_in_sighandler(value):  # -> None:
    """Set flag signifiying that we're inside a signal handler."""
    ...

def iter_open_logger_fds(): ...
@contextmanager
def in_sighandler():  # -> Generator[None, None, None]:
    """Context that records that we are in a signal handler."""
    ...

def logger_isa(l, p, max=...): ...
def get_logger(name):  # -> Logger:
    """Get logger by name."""
    ...

task_logger = ...
worker_logger = ...

def get_task_logger(name):  # -> Logger:
    """Get logger for task module by name."""
    ...

def mlevel(level):  # -> int | Integral:
    """Convert level name/int to log level."""
    ...

class ColorFormatter(logging.Formatter):
    """Logging formatter that adds colors based on severity."""

    COLORS = ...
    colors = ...
    def __init__(self, fmt=..., use_color=...) -> None: ...
    def formatException(self, ei): ...
    def format(self, record): ...

class LoggingProxy:
    """Forward file object to :class:`logging.Logger` instance.

    Arguments:
        logger (~logging.Logger): Logger instance to forward to.
        loglevel (int, str): Log level to use when logging messages.
    """

    mode = ...
    name = ...
    closed = ...
    loglevel = ...
    _thread = ...
    def __init__(self, logger, loglevel=...) -> None: ...
    def write(self, data: AnyStr) -> int:
        """Write message to logging object."""
        ...
    def writelines(self, sequence: Sequence[str]) -> None:
        """Write list of strings to file.

        The sequence can be any iterable object producing strings.
        This is equivalent to calling :meth:`write` for each string.
        """
        ...
    def flush(self): ...
    def close(self): ...
    def isatty(self):  # -> Literal[False]:
        """Here for file support."""
        ...

def get_multiprocessing_logger():  # -> Logger | None:
    """Return the multiprocessing logger."""
    ...

def reset_multiprocessing_logger():  # -> None:
    """Reset multiprocessing logging setup."""
    ...

def current_process(): ...
def current_process_index(base=...): ...
