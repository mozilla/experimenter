"""
This type stub file was generated by pyright.
"""

from collections import UserDict

from celery.utils.collections import AttributeDictMixin
from kombu.utils.objects import cached_property

from .utils import AppPickler

"""Actual App instance implementation."""
__all__ = ("Celery",)
logger = ...
BUILTIN_FIXUPS = ...
USING_EXECV = ...
ERR_ENVVAR_NOT_SET = ...

def app_has_custom(app, attr):  # -> None:
    """Return true if app has customized method `attr`.

    Note:
        This is used for optimizations in cases where we know
        how the default behavior works, but need to account
        for someone using inheritance to override a method/property.
    """
    ...

class PendingConfiguration(UserDict, AttributeDictMixin):
    callback = ...
    _data = ...
    def __init__(self, conf, callback) -> None: ...
    def __setitem__(self, key, value): ...
    def clear(self): ...
    def update(self, *args, **kwargs): ...
    def setdefault(self, *args, **kwargs): ...
    def __contains__(self, key): ...
    def __len__(self): ...
    def __repr__(self): ...
    @cached_property
    def data(self): ...

class Celery:
    """Celery application.

    Arguments:
        main (str): Name of the main module if running as `__main__`.
            This is used as the prefix for auto-generated task names.

    Keyword Arguments:
        broker (str): URL of the default broker used.
        backend (Union[str, Type[celery.backends.base.Backend]]):
            The result store backend class, or the name of the backend
            class to use.

            Default is the value of the :setting:`result_backend` setting.
        autofinalize (bool): If set to False a :exc:`RuntimeError`
            will be raised if the task registry or tasks are used before
            the app is finalized.
        set_as_current (bool):  Make this the global current app.
        include (List[str]): List of modules every worker should import.

        amqp (Union[str, Type[AMQP]]): AMQP object or class name.
        events (Union[str, Type[celery.app.events.Events]]): Events object or
            class name.
        log (Union[str, Type[Logging]]): Log object or class name.
        control (Union[str, Type[celery.app.control.Control]]): Control object
            or class name.
        tasks (Union[str, Type[TaskRegistry]]): A task registry, or the name of
            a registry class.
        fixups (List[str]): List of fix-up plug-ins (e.g., see
            :mod:`celery.fixups.django`).
        config_source (Union[str, class]): Take configuration from a class,
            or object.  Attributes may include any settings described in
            the documentation.
        task_cls (Union[str, Type[celery.app.task.Task]]): base task class to
            use. See :ref:`this section <custom-task-cls-app-wide>` for usage.
    """

    Pickler = AppPickler
    SYSTEM = ...
    main = ...
    user_options = ...
    steps = ...
    builtin_fixups = ...
    amqp_cls = ...
    backend_cls = ...
    events_cls = ...
    loader_cls = ...
    log_cls = ...
    control_cls = ...
    task_cls = ...
    registry_cls = ...
    _local = ...
    _fixups = ...
    _pool = ...
    _conf = ...
    _after_fork_registered = ...
    on_configure = ...
    on_after_configure = ...
    on_after_finalize = ...
    on_after_fork = ...
    def __init__(
        self,
        main=...,
        loader=...,
        backend=...,
        amqp=...,
        events=...,
        log=...,
        control=...,
        set_as_current=...,
        tasks=...,
        broker=...,
        include=...,
        changes=...,
        config_source=...,
        fixups=...,
        task_cls=...,
        autofinalize=...,
        namespace=...,
        strict_typing=...,
        **kwargs
    ) -> None: ...
    def on_init(self):  # -> None:
        """Optional callback called at init."""
        ...
    def set_current(self):  # -> None:
        """Make this the current app for this thread."""
        ...
    def set_default(self):  # -> None:
        """Make this the default app for all threads."""
        ...
    def close(self):  # -> None:
        """Clean up after the application.

        Only necessary for dynamically created apps, and you should
        probably use the :keyword:`with` statement instead.

        Example:
            >>> with Celery(set_as_current=False) as app:
            ...     with app.connection_for_write() as conn:
            ...         pass
        """
        ...
    def start(self, argv=...):  # -> int | None:
        """Run :program:`celery` using `argv`.

        Uses :data:`sys.argv` if `argv` is not specified.
        """
        ...
    def worker_main(self, argv=...):  # -> None:
        """Run :program:`celery worker` using `argv`.

        Uses :data:`sys.argv` if `argv` is not specified.
        """
        ...
    def task(
        self, *args, **opts
    ):  # -> Proxy | ((fun: Unknown) -> Proxy) | Any | PromiseProxy | ((fun: Unknown) -> (Unknown | Any | PromiseProxy)):
        """Decorator to create a task class out of any callable.

        See :ref:`Task options<task-options>` for a list of the
        arguments that can be passed to this decorator.

        Examples:
            .. code-block:: python

                @app.task
                def refresh_feed(url):
                    store_feed(feedparser.parse(url))

            with setting extra options:

            .. code-block:: python

                @app.task(exchange='feeds')
                def refresh_feed(url):
                    return store_feed(feedparser.parse(url))

        Note:
            App Binding: For custom apps the task decorator will return
            a proxy object, so that the act of creating the task is not
            performed until the task is used or the task registry is accessed.

            If you're depending on binding to be deferred, then you must
            not access any attributes on the returned object until the
            application is fully set up (finalized).
        """
        ...
    def register_task(self, task, **options):  # -> Any | type:
        """Utility for registering a task-based class.

        Note:
            This is here for compatibility with old Celery 1.0
            style task classes, you should not need to use this for
            new projects.
        """
        ...
    def gen_task_name(self, name, module): ...
    def finalize(self, auto=...):  # -> None:
        """Finalize the app.

        This loads built-in tasks, evaluates pending task decorators,
        reads configuration, etc.
        """
        ...
    def add_defaults(self, fun):  # -> None:
        """Add default configuration from dict ``d``.

        If the argument is a callable function then it will be regarded
        as a promise, and it won't be loaded until the configuration is
        actually needed.

        This method can be compared to:

        .. code-block:: pycon

            >>> celery.conf.update(d)

        with a difference that 1) no copy will be made and 2) the dict will
        not be transferred when the worker spawns child processes, so
        it's important that the same configuration happens at import time
        when pickle restores the object on the other side.
        """
        ...
    def config_from_object(
        self, obj, silent=..., force=..., namespace=...
    ):  # -> Settings | None:
        """Read configuration from object.

        Object is either an actual object or the name of a module to import.

        Example:
            >>> celery.config_from_object('myapp.celeryconfig')

            >>> from myapp import celeryconfig
            >>> celery.config_from_object(celeryconfig)

        Arguments:
            silent (bool): If true then import errors will be ignored.
            force (bool): Force reading configuration immediately.
                By default the configuration will be read only when required.
        """
        ...
    def config_from_envvar(
        self, variable_name, silent=..., force=...
    ):  # -> Settings | Literal[False] | None:
        """Read configuration from environment variable.

        The value of the environment variable must be the name
        of a module to import.

        Example:
            >>> os.environ['CELERY_CONFIG_MODULE'] = 'myapp.celeryconfig'
            >>> celery.config_from_envvar('CELERY_CONFIG_MODULE')
        """
        ...
    def config_from_cmdline(self, argv, namespace=...): ...
    def setup_security(
        self,
        allowed_serializers=...,
        key=...,
        cert=...,
        store=...,
        digest=...,
        serializer=...,
    ):  # -> None:
        """Setup the message-signing serializer.

        This will affect all application instances (a global operation).

        Disables untrusted serializers and if configured to use the ``auth``
        serializer will register the ``auth`` serializer with the provided
        settings into the Kombu serializer registry.

        Arguments:
            allowed_serializers (Set[str]): List of serializer names, or
                content_types that should be exempt from being disabled.
            key (str): Name of private key file to use.
                Defaults to the :setting:`security_key` setting.
            cert (str): Name of certificate file to use.
                Defaults to the :setting:`security_certificate` setting.
            store (str): Directory containing certificates.
                Defaults to the :setting:`security_cert_store` setting.
            digest (str): Digest algorithm used when signing messages.
                Default is ``sha256``.
            serializer (str): Serializer used to encode messages after
                they've been signed.  See :setting:`task_serializer` for
                the serializers supported.  Default is ``json``.
        """
        ...
    def autodiscover_tasks(self, packages=..., related_name=..., force=...):  # -> None:
        """Auto-discover task modules.

        Searches a list of packages for a "tasks.py" module (or use
        related_name argument).

        If the name is empty, this will be delegated to fix-ups (e.g., Django).

        For example if you have a directory layout like this:

        .. code-block:: text

            foo/__init__.py
               tasks.py
               models.py

            bar/__init__.py
                tasks.py
                models.py

            baz/__init__.py
                models.py

        Then calling ``app.autodiscover_tasks(['foo', 'bar', 'baz'])`` will
        result in the modules ``foo.tasks`` and ``bar.tasks`` being imported.

        Arguments:
            packages (List[str]): List of packages to search.
                This argument may also be a callable, in which case the
                value returned is used (for lazy evaluation).
            related_name (Optional[str]): The name of the module to find.  Defaults
                to "tasks": meaning "look for 'module.tasks' for every
                module in ``packages``.".  If ``None`` will only try to import
                the package, i.e. "look for 'module'".
            force (bool): By default this call is lazy so that the actual
                auto-discovery won't happen until an application imports
                the default modules.  Forcing will cause the auto-discovery
                to happen immediately.
        """
        ...
    def send_task(
        self,
        name,
        args=...,
        kwargs=...,
        countdown=...,
        eta=...,
        task_id=...,
        producer=...,
        connection=...,
        router=...,
        result_cls=...,
        expires=...,
        publisher=...,
        link=...,
        link_error=...,
        add_to_parent=...,
        group_id=...,
        group_index=...,
        retries=...,
        chord=...,
        reply_to=...,
        time_limit=...,
        soft_time_limit=...,
        root_id=...,
        parent_id=...,
        route_name=...,
        shadow=...,
        chain=...,
        task_type=...,
        **options
    ):
        """Send task by name.

        Supports the same arguments as :meth:`@-Task.apply_async`.

        Arguments:
            name (str): Name of task to call (e.g., `"tasks.add"`).
            result_cls (AsyncResult): Specify custom result class.
        """
        ...
    def connection_for_read(self, url=..., **kwargs):
        """Establish connection used for consuming.

        See Also:
            :meth:`connection` for supported arguments.
        """
        ...
    def connection_for_write(self, url=..., **kwargs):
        """Establish connection used for producing.

        See Also:
            :meth:`connection` for supported arguments.
        """
        ...
    def connection(
        self,
        hostname=...,
        userid=...,
        password=...,
        virtual_host=...,
        port=...,
        ssl=...,
        connect_timeout=...,
        transport=...,
        transport_options=...,
        heartbeat=...,
        login_method=...,
        failover_strategy=...,
        **kwargs
    ):
        """Establish a connection to the message broker.

        Please use :meth:`connection_for_read` and
        :meth:`connection_for_write` instead, to convey the intent
        of use for this connection.

        Arguments:
            url: Either the URL or the hostname of the broker to use.
            hostname (str): URL, Hostname/IP-address of the broker.
                If a URL is used, then the other argument below will
                be taken from the URL instead.
            userid (str): Username to authenticate as.
            password (str): Password to authenticate with
            virtual_host (str): Virtual host to use (domain).
            port (int): Port to connect to.
            ssl (bool, Dict): Defaults to the :setting:`broker_use_ssl`
                setting.
            transport (str): defaults to the :setting:`broker_transport`
                setting.
            transport_options (Dict): Dictionary of transport specific options.
            heartbeat (int): AMQP Heartbeat in seconds (``pyamqp`` only).
            login_method (str): Custom login method to use (AMQP only).
            failover_strategy (str, Callable): Custom failover strategy.
            **kwargs: Additional arguments to :class:`kombu.Connection`.

        Returns:
            kombu.Connection: the lazy connection instance.
        """
        ...
    broker_connection = ...
    def connection_or_acquire(
        self, connection=..., pool=..., *_, **__
    ):  # -> FallbackContext:
        """Context used to acquire a connection from the pool.

        For use within a :keyword:`with` statement to get a connection
        from the pool if one is not already provided.

        Arguments:
            connection (kombu.Connection): If not provided, a connection
                will be acquired from the connection pool.
        """
        ...
    default_connection = ...
    def producer_or_acquire(self, producer=...):  # -> FallbackContext:
        """Context used to acquire a producer from the pool.

        For use within a :keyword:`with` statement to get a producer
        from the pool if one is not already provided

        Arguments:
            producer (kombu.Producer): If not provided, a producer
                will be acquired from the producer pool.
        """
        ...
    default_producer = ...
    def prepare_config(self, c):
        """Prepare configuration before it is merged with the defaults."""
        ...
    def now(self):
        """Return the current time and date as a datetime."""
        ...
    def select_queues(self, queues=...):
        """Select subset of queues.

        Arguments:
            queues (Sequence[str]): a list of queue names to keep.
        """
        ...
    def either(self, default_key, *defaults):  # -> Any | MethodType | None:
        """Get key from configuration or use default values.

        Fallback to the value of a configuration key if none of the
        `*values` are true.
        """
        ...
    def bugreport(self):  # -> str:
        """Return information useful in bug reports."""
        ...
    def signature(self, *args, **kwargs):
        """Return a new :class:`~celery.Signature` bound to this app."""
        ...
    def add_periodic_task(
        self, schedule, sig, args=..., kwargs=..., name=..., **opts
    ): ...
    def create_task_cls(self):  # -> Any:
        """Create a base task class bound to this app."""
        ...
    def subclass_with_self(
        self, Class, name=..., attribute=..., reverse=..., keep_reduce=..., **kw
    ):  # -> Any:
        """Subclass an app-compatible class.

        App-compatible means that the class has a class attribute that
        provides the default app it should use, for example:
        ``class Foo: app = None``.

        Arguments:
            Class (type): The app-compatible class to subclass.
            name (str): Custom name for the target class.
            attribute (str): Name of the attribute holding the app,
                Default is 'app'.
            reverse (str): Reverse path to this object used for pickling
                purposes. For example, to get ``app.AsyncResult``,
                use ``"AsyncResult"``.
            keep_reduce (bool): If enabled a custom ``__reduce__``
                implementation won't be provided.
        """
        ...
    def __enter__(self): ...
    def __exit__(self, *exc_info): ...
    def __repr__(self): ...
    def __reduce__(self): ...
    def __reduce_v1__(self): ...
    def __reduce_keys__(
        self,
    ):  # -> dict[str, Unknown | str | set[str] | dict[Any, Any] | None]:
        """Keyword arguments used to reconstruct the object when unpickling."""
        ...
    def __reduce_args__(
        self,
    ):  # -> tuple[Unknown | None, Unknown | dict[Unknown, Unknown] | None, Unknown | None, None, str | Unknown, str | Unknown, str | Unknown, str | Unknown, Literal[False], Unknown | None]:
        """Deprecated method, please use :meth:`__reduce_keys__` instead."""
        ...
    @cached_property
    def Worker(self):  # -> Any:
        """Worker application.

        See Also:
            :class:`~@Worker`.
        """
        ...
    @cached_property
    def WorkController(self, **kwargs):  # -> Any:
        """Embeddable worker.

        See Also:
            :class:`~@WorkController`.
        """
        ...
    @cached_property
    def Beat(self, **kwargs):  # -> Any:
        """:program:`celery beat` scheduler application.

        See Also:
            :class:`~@Beat`.
        """
        ...
    @cached_property
    def Task(self):  # -> Any:
        """Base task class for this app."""
        ...
    @cached_property
    def annotations(self): ...
    @cached_property
    def AsyncResult(self):  # -> Any:
        """Create new result instance.

        See Also:
            :class:`celery.result.AsyncResult`.
        """
        ...
    @cached_property
    def ResultSet(self): ...
    @cached_property
    def GroupResult(self):  # -> Any:
        """Create new group result instance.

        See Also:
            :class:`celery.result.GroupResult`.
        """
        ...
    @property
    def pool(self):
        """Broker connection pool: :class:`~@pool`.

        Note:
            This attribute is not related to the workers concurrency pool.
        """
        ...
    @property
    def current_task(self):  # -> None:
        """Instance of task being executed, or :const:`None`."""
        ...
    @property
    def current_worker_task(self):  # -> None:
        """The task currently being executed by a worker or :const:`None`.

        Differs from :data:`current_task` in that it's not affected
        by tasks calling other tasks directly, or eagerly.
        """
        ...
    @cached_property
    def oid(self):  # -> str:
        """Universally unique identifier for this app."""
        ...
    @property
    def thread_oid(self):  # -> Any | str:
        """Per-thread unique identifier for this app."""
        ...
    @cached_property
    def amqp(self):  # -> Any:
        """AMQP related functionality: :class:`~@amqp`."""
        ...
    @property
    def backend(self):  # -> Any:
        """Current backend instance."""
        ...
    @property
    def conf(self):  # -> Settings:
        """Current configuration."""
        ...
    @conf.setter
    def conf(self, d): ...
    @cached_property
    def control(self):  # -> Any:
        """Remote control: :class:`~@control`."""
        ...
    @cached_property
    def events(self):  # -> Any:
        """Consuming and sending events: :class:`~@events`."""
        ...
    @cached_property
    def loader(self):  # -> Any:
        """Current loader instance."""
        ...
    @cached_property
    def log(self):  # -> Any:
        """Logging: :class:`~@log`."""
        ...
    @cached_property
    def tasks(self):  # -> Any | None:
        """Task registry.

        Warning:
            Accessing this attribute will also auto-finalize the app.
        """
        ...
    @property
    def producer_pool(self): ...
    def uses_utc_timezone(self):
        """Check if the application uses the UTC timezone."""
        ...
    @cached_property
    def timezone(self):  # -> _UTCclass | StaticTzInfo | DstTzInfo | Any:
        """Current timezone for this app.

        This is a cached property taking the time zone from the
        :setting:`timezone` setting.
        """
        ...

App = Celery
