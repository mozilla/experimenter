"""
This type stub file was generated by pyright.
"""

"""Build factory instances."""
DeclarationWithContext = ...

class DeclarationSet:
    """A set of declarations, including the recursive parameters.

    Attributes:
        declarations (dict(name => declaration)): the top-level declarations
        contexts (dict(name => dict(subfield => value))): the nested parameters related
            to a given top-level declaration

    This object behaves similarly to a dict mapping a top-level declaration name to a
    DeclarationWithContext, containing field name, declaration object and extra context.
    """

    def __init__(self, initial=...) -> None: ...
    @classmethod
    def split(cls, entry):  # -> tuple[Unknown, None]:
        """Split a declaration name into a (declaration, subpath) tuple.

        Examples:
        >>> DeclarationSet.split('foo__bar')
        ('foo', 'bar')
        >>> DeclarationSet.split('foo')
        ('foo', None)
        >>> DeclarationSet.split('foo__bar__baz')
        ('foo', 'bar__baz')
        """
        ...
    @classmethod
    def join(cls, root, subkey):  # -> LiteralString:
        """Rebuild a full declaration name from its components.

        for every string x, we have `join(split(x)) == x`.
        """
        ...
    def copy(self): ...
    def update(self, values):  # -> None:
        """Add new declarations to this set/

        Args:
            values (dict(name, declaration)): the declarations to ingest.
        """
        ...
    def filter(self, entries):  # -> list[Unknown]:
        """Filter a set of declarations: keep only those related to this object.

        This will keep:
        - Declarations that 'override' the current ones
        - Declarations that are parameters to current ones
        """
        ...
    def sorted(self): ...
    def __contains__(self, key): ...
    def __getitem__(self, key): ...
    def __iter__(self): ...
    def values(self):  # -> Generator[DeclarationWithContext, None, None]:
        """Retrieve the list of declarations, with their context."""
        ...
    def as_dict(self):  # -> dict[Unknown | LiteralString, Unknown]:
        """Return a dict() suitable for our __init__."""
        ...
    def __repr__(self): ...

def parse_declarations(decls, base_pre=..., base_post=...): ...

class BuildStep:
    def __init__(self, builder, sequence, parent_step=...) -> None: ...
    def resolve(self, declarations): ...
    @property
    def chain(self): ...
    def recurse(self, factory, declarations, force_sequence=...): ...
    def __repr__(self): ...

class StepBuilder:
    """A factory instantiation step.

    Attributes:
    - parent: the parent StepBuilder, or None for the root step
    - extras: the passed-in kwargs for this branch
    - factory: the factory class being built
    - strategy: the strategy to use
    """

    def __init__(self, factory_meta, extras, strategy) -> None: ...
    def build(self, parent_step=..., force_sequence=...):
        """Build a factory instance."""
        ...
    def recurse(self, factory_meta, extras):  # -> Self@StepBuilder:
        """Recurse into a sub-factory call."""
        ...
    def __repr__(self): ...

class Resolver:
    """Resolve a set of declarations.

    Attributes are set at instantiation time, values are computed lazily.

    Attributes:
        __initialized (bool): whether this object's __init__ as run. If set,
            setting any attribute will be prevented.
        __declarations (dict): maps attribute name to their declaration
        __values (dict): maps attribute name to computed value
        __pending (str list): names of the attributes whose value is being
            computed. This allows to detect cyclic lazy attribute definition.
        __step (BuildStep): the BuildStep related to this resolver.
            This allows to have the value of a field depend on the value of
            another field
    """

    __initialized = ...
    def __init__(self, declarations, step, sequence) -> None: ...
    @property
    def factory_parent(self): ...
    def __repr__(self): ...
    def __getattr__(self, name):
        """Retrieve an attribute's value.

        This will compute it if needed, unless it is already on the list of
        attributes being computed.
        """
        ...
    def __setattr__(self, name, value):  # -> None:
        """Prevent setting attributes once __init__ is done."""
        ...
