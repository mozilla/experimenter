import { validate } from "@cfworker/json-schema";
import jsonToAst from "json-to-ast";
import { z } from "zod";

/**
 * A simplified schema that is generated by a feature manifest entry with only a
 * simple list of variables.
 */
export const simpleObjectSchema = z.object({
  type: z.literal("object"),
  properties: z.record(
    z.object({
      type: z.optional(
        z.union([
          z.literal("integer"),
          z.literal("boolean"),
          z.literal("string"),
        ]),
      ),
    }),
  ),
});

export function detectDraft(schema) {
  let draft = "2019-09";
  const { $schema } = schema;

  switch ($schema) {
    case "http://json-schema.org/draft-04/schema#":
      draft = "4";
      break;

    case "http://json-schema.org/draft-07/schema#":
      draft = "7";
      break;

    case "https://json-schema.org/draft/2019-09/schema":
      draft = "2019-09";
      break;

    case "https://json-schema.org/draft/2020-12/schema":
      draft = "2020-12";
      break;
  }

  return draft;
}

export function schemaLinter(schema) {
  const draft = detectDraft(schema);

  const EMPTY_STRING_RE = /^\s*$/;

  const SCHEMA_RE = /^Property ".*" does not match schema\.$/;
  const ADDITIONAL_PROPERTIES_RE =
    /^Property "(.*)" does not match additional properties schema.$/;

  // Errors that are ignored because they are always accompanied by a more
  // specific, useful error message.
  const IGNORED_ERRORS = [
    "A subschema had errors.",
    `Instance does not match "then" schema.`,
    `Instance does not match "else" schema.`,
    "Instance does not match every subschema.",
    "Items did not match schema.",
  ];

  // An error message for when additionalProperties is false and either the
  // property does not exist or its value has the wrong type.
  const FALSE_BOOLEAN_SCHEMA = "False boolean schema.";

  const ADDITIONAL_PROPERTIES = "additionalProperties";

  return function (view) {
    const text = view.state.doc.toString();

    try {
      JSON.parse(text);
    } catch (e) {
      return [];
    }

    if (EMPTY_STRING_RE.test(text)) {
      return [];
    }

    let rootNode;
    try {
      rootNode = jsonToAst(text);
    } catch (e) {
      return [];
    }

    // We know JSON.parse(text) will succeed because we already parsed text into
    // an ast above.

    const validationResult = validate(
      JSON.parse(text),
      schema,
      draft,
      undefined,
      false,
    );

    const diagnostics = [];

    // Keep track of type errors reported by instanceLocation, because a more
    // specific type error will be followed by less helpful, more generic
    // errors.
    const typeErrors = new Set();

    for (const error of validationResult.errors) {
      let message = error.error;

      if (SCHEMA_RE.exec(message)) {
        // We will get a more specific error later.
        continue;
      }

      const instancePath = error.instanceLocation.split("/").slice(1);
      let instanceLocation = error.instanceLocation;
      let nodeKey = "value";

      if (error.keyword === "type" && instancePath.length) {
        typeErrors.add(error.instanceLocation);
      } else if (error.keyword === ADDITIONAL_PROPERTIES) {
        const match = ADDITIONAL_PROPERTIES_RE.exec(message);
        if (match) {
          const propertyName = match[1];

          // This error gets reported on the object, not the property. Suppress
          // this error if we've already reported a type error for the property.
          instanceLocation = `${error.instanceLocation}/${propertyName}`;
          if (typeErrors.has(instanceLocation)) {
            continue;
          }

          typeErrors.add(instanceLocation);
          instancePath.push(propertyName);
          message = `Unexpected property "${propertyName}"`;
          nodeKey = "key";
        }
      } else if (
        IGNORED_ERRORS.includes(message) ||
        (message === FALSE_BOOLEAN_SCHEMA &&
          typeErrors.has(error.instanceLocation))
      ) {
        continue;
      }

      const pos = findNode(rootNode, instancePath)[nodeKey].loc;
      const from = documentPosition(
        view.state.doc,
        pos.start.line,
        pos.start.column - 1,
      );
      const to = documentPosition(
        view.state.doc,
        pos.end.line,
        pos.end.column - 1,
      );

      diagnostics.push(createDiagnostic(from, to, message));
    }

    reportFloatValues(view.state.doc, rootNode, diagnostics);

    return diagnostics;
  };
}

/**
 * Return the position given by a line and column in the given document.
 */
function documentPosition(doc, line, column) {
  return doc.line(line).from + column;
}

/**
 * Parse an error into a Diagnostic
 */
function createDiagnostic(from, to, message, severity = "error") {
  return {
    from: from,
    to: to,
    message: message,
    severity: severity,
  };
}

function findNode(node, path) {
  if (path.length === 0) {
    return { value: node };
  } else if (node.type === "Object") {
    const child = node.children.find((child) => child.key.value === path[0]);

    if (path.length === 1) {
      return {
        value: child.value,
        key: child.key,
      };
    }

    return findNode(child.value, path.slice(1));
  } else if (node.type === "Array") {
    const idx = parseInt(path[0]);
    return findNode(node.children[idx], path.slice(1));
  }

  throw new Error("unreachable");
}

/**
 * Report an error for each floating point value in the AST.
 */
function reportFloatValues(doc, node, diagnostics) {
  switch (node.type) {
    case "Array":
      for (const child of node.children) {
        reportFloatValues(doc, child, diagnostics);
      }
      break;

    case "Object":
      for (const child of node.children) {
        reportFloatValues(doc, child.value, diagnostics);
      }
      break;

    case "Literal":
      if (typeof node.value === "number" && ~~node.value !== node.value) {
        const loc = node.loc;
        diagnostics.push(
          createDiagnostic(
            documentPosition(doc, loc.start.line, loc.start.column),
            documentPosition(doc, loc.start.line, loc.start.column),
            "Floats are not supported",
          ),
        );
      }
      break;
  }
}

/**
 * JSON Schema-based autocompletion provider.
 *
 * The returned provider can only infer the top-level property names of very
 * simple JSON schemas.
 */
export function schemaAutocomplete(schema) {
  let simpleObject;
  try {
    simpleObject = simpleObjectSchema.parse(schema);
  } catch (ex) {
    console.log(
      "Schema is not a simple object schema, cannot provide autocompletion.",
      ex,
    );
    return null;
  }

  const variableNames = Object.keys(simpleObject.properties);

  return (context) => {
    const pos = context.pos;
    const line = context.state.doc.lineAt(pos);
    const before = line.text.slice(0, pos - line.from);
    // Only trigger if the last character typed is a double quote
    if (!before.endsWith('"')) return null;
    return {
      from: pos,
      options: variableNames.map((token) => ({
        label: token,
        type: "keyword",
      })),
    };
  };
}

/**
 * FML remote feature validation
 * Linter that calls out to the server to validate feature values against
 * FML rules.
 */
export const fmlLinter = (experimentSlug, featureSlug) => {
  let timeout = null;

  return async (view) => {
    const doc = view.state.doc.toString();

    if (timeout) {
      clearTimeout(timeout);
    }

    if (!doc.trim()) {
      return [];
    }

    try {
      JSON.parse(doc);
    } catch (e) {
      return [];
    }

    return new Promise((resolve) => {
      timeout = setTimeout(async () => {
        try {
          const response = await fetch(
            `/api/v5/fml-errors/${experimentSlug}/`,
            {
              method: "PATCH",
              headers: {
                "Content-Type": "application/json",
                "X-CSRFToken": document.querySelector(
                  "[name=csrfmiddlewaretoken]",
                ).value,
              },
              body: JSON.stringify({
                featureSlug: featureSlug,
                featureValue: doc,
              }),
            },
          );

          if (!response.ok) {
            resolve([]);
            return;
          }

          const errors = await response.json();

          const diagnostics = errors.map((error) => {
            const line = Math.max(0, error.line - 1);
            const col = Math.max(0, error.col - 1);

            const lineObj = view.state.doc.line(line + 1);
            const from = lineObj.from + col;
            const to = from + (error.highlight?.length || 1);

            return {
              from,
              to,
              severity: "error",
              message: error.message,
            };
          });

          resolve(diagnostics);
        } catch (error) {
          console.error("FML validation error:", error);
          resolve([]);
        }
      }, 500);
    });
  };
};
