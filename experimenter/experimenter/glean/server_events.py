"""
This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at http://mozilla.org/MPL/2.0/.

AUTOGENERATED BY glean_parser v18.0.6.post1.dev0+gb423bb9f7.d20251031. DO NOT EDIT. DO NOT COMMIT.
"""

from __future__ import annotations
from datetime import datetime, timezone
from typing import Any
from uuid import uuid4
import json

GLEAN_EVENT_MOZLOG_TYPE = "glean-server-event"


class PageViewServerEventLogger:
    def __init__(
        self, application_id: str, app_display_version: str, channel: str
    ) -> None:
        """
        Create PageViewServerEventLogger instance.

        :param str application_id: The application ID.
        :param str app_display_version: The application display version.
        :param str channel: The channel.
        """
        self._application_id = application_id
        self._app_display_version = app_display_version
        self._channel = channel

    def record(
        self,
        user_agent: str,
        ip_address: str,
        nimbus_enrollments: Any,
        nimbus_nimbus_user_id: str,
        url_path: str,
        events: list[dict[str, Any]]
    ) -> None:
        now = datetime.now(timezone.utc)
        timestamp = now.isoformat()
        for event in events:
            event["timestamp"] = int(1000.0 * now.timestamp())  # Milliseconds since epoch
        event_payload = {
            "metrics": {
                "string": {
                    "nimbus.enrollments": nimbus_enrollments,
                    "nimbus.nimbus_user_id": nimbus_nimbus_user_id,
                    "url.path": url_path,
                },
            },
            "events": events,
            "ping_info": {
                # seq is required in the Glean schema, however is not useful in server context
                "seq": 0,
                "start_time": timestamp,
                "end_time": timestamp,
            },
            # `Unknown` fields below are required in the Glean schema, however they are
            # not useful in server context
            "client_info": {
                "telemetry_sdk_build": "glean_parser v18.0.6.post1.dev0+gb423bb9f7.d20251031",
                "first_run_date": "Unknown",
                "os": "Unknown",
                "os_version": "Unknown",
                "architecture": "Unknown",
                "app_build": "Unknown",
                "app_display_version": self._app_display_version,
                "app_channel": self._channel,
            },
        }
        event_payload_serialized = json.dumps(event_payload)

        # This is the message structure that Decoder expects:
        # https://github.com/mozilla/gcp-ingestion/pull/2400
        ping = {
            "document_namespace": self._application_id,
            "document_type": "page-view",
            "document_version": "1",
            "document_id": str(uuid4()),
            "user_agent": user_agent,
            "ip_address": ip_address,
            "payload": event_payload_serialized,
        }


        self.emit_record(now, ping)

    def emit_record(self, now: datetime, ping:dict[str, Any]) -> None:
        """Log the ping to STDOUT.
        Applications might want to override this method to use their own logging.
        If doing so, make sure to log the ping as JSON, and to include the
        `Type: GLEAN_EVENT_MOZLOG_TYPE`."""
        ping_envelope = {
            "Timestamp": now.isoformat(),
            "Logger": "glean",
            "Type": GLEAN_EVENT_MOZLOG_TYPE,
            "Fields": ping,
        }
        ping_envelope_serialized = json.dumps(ping_envelope)

        print(ping_envelope_serialized)

class DataCollectionOptOutServerEventLogger:
    def __init__(
        self, application_id: str, app_display_version: str, channel: str
    ) -> None:
        """
        Create DataCollectionOptOutServerEventLogger instance.

        :param str application_id: The application ID.
        :param str app_display_version: The application display version.
        :param str channel: The channel.
        """
        self._application_id = application_id
        self._app_display_version = app_display_version
        self._channel = channel

    def record(
        self,
        user_agent: str,
        ip_address: str,
        nimbus_nimbus_user_id: str,
        events: list[dict[str, Any]]
    ) -> None:
        now = datetime.now(timezone.utc)
        timestamp = now.isoformat()
        for event in events:
            event["timestamp"] = int(1000.0 * now.timestamp())  # Milliseconds since epoch
        event_payload = {
            "metrics": {
                "string": {
                    "nimbus.nimbus_user_id": nimbus_nimbus_user_id,
                },
            },
            "events": events,
            "ping_info": {
                # seq is required in the Glean schema, however is not useful in server context
                "seq": 0,
                "start_time": timestamp,
                "end_time": timestamp,
            },
            # `Unknown` fields below are required in the Glean schema, however they are
            # not useful in server context
            "client_info": {
                "telemetry_sdk_build": "glean_parser v18.0.6.post1.dev0+gb423bb9f7.d20251031",
                "first_run_date": "Unknown",
                "os": "Unknown",
                "os_version": "Unknown",
                "architecture": "Unknown",
                "app_build": "Unknown",
                "app_display_version": self._app_display_version,
                "app_channel": self._channel,
            },
        }
        event_payload_serialized = json.dumps(event_payload)

        # This is the message structure that Decoder expects:
        # https://github.com/mozilla/gcp-ingestion/pull/2400
        ping = {
            "document_namespace": self._application_id,
            "document_type": "data-collection-opt-out",
            "document_version": "1",
            "document_id": str(uuid4()),
            "user_agent": user_agent,
            "ip_address": ip_address,
            "payload": event_payload_serialized,
        }


        self.emit_record(now, ping)

    def emit_record(self, now: datetime, ping:dict[str, Any]) -> None:
        """Log the ping to STDOUT.
        Applications might want to override this method to use their own logging.
        If doing so, make sure to log the ping as JSON, and to include the
        `Type: GLEAN_EVENT_MOZLOG_TYPE`."""
        ping_envelope = {
            "Timestamp": now.isoformat(),
            "Logger": "glean",
            "Type": GLEAN_EVENT_MOZLOG_TYPE,
            "Fields": ping,
        }
        ping_envelope_serialized = json.dumps(ping_envelope)

        print(ping_envelope_serialized)


def create_page_view_server_event_logger(
    application_id: str,
    app_display_version: str,
    channel: str,
) -> PageViewServerEventLogger:
    """
    Factory function that creates an instance of Glean Server Event Logger to record
    `page-view` ping events.
    :param str application_id: The application ID.
    :param str app_display_version: The application display version.
    :param str channel: The channel.
    :return: An instance of PageViewServerEventLogger.
    :rtype: PageViewServerEventLogger
    """
    return PageViewServerEventLogger(application_id, app_display_version, channel)
def create_data_collection_opt_out_server_event_logger(
    application_id: str,
    app_display_version: str,
    channel: str,
) -> DataCollectionOptOutServerEventLogger:
    """
    Factory function that creates an instance of Glean Server Event Logger to record
    `data-collection-opt-out` ping events.
    :param str application_id: The application ID.
    :param str app_display_version: The application display version.
    :param str channel: The channel.
    :return: An instance of DataCollectionOptOutServerEventLogger.
    :rtype: DataCollectionOptOutServerEventLogger
    """
    return DataCollectionOptOutServerEventLogger(application_id, app_display_version, channel)
