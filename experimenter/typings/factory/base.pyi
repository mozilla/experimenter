"""
This type stub file was generated by pyright.
"""

from . import errors

logger = ...

def get_factory_bases(bases):  # -> list[Type[BaseFactory]]:
    """Retrieve all FactoryMetaClass-derived bases from a list."""
    ...

def resolve_attribute(name, bases, default=...):  # -> Any | None:
    """Find the first definition of an attribute according to MRO order."""
    ...

class FactoryMetaClass(type):
    """Factory metaclass for handling ordered declarations."""

    def __call__(cls, **kwargs):
        """Override the default Factory() syntax to call the default strategy.

        Returns an instance of the associated class.
        """
        ...
    def __new__(mcs, class_name, bases, attrs):  # -> Self@FactoryMetaClass:
        """Record attributes as a pattern for later instance construction.

        This is called when a new Factory subclass is defined; it will collect
        attribute declaration from the class definition.

        Args:
            class_name (str): the name of the class being created
            bases (list of class): the parents of the class being created
            attrs (str => obj dict): the attributes as defined in the class
                definition

        Returns:
            A new class
        """
        ...
    def __str__(cls) -> str: ...

class BaseMeta:
    abstract = ...
    strategy = ...

class OptionDefault:
    """The default for an option.

    Attributes:
        name: str, the name of the option ('class Meta' attribute)
        value: object, the default value for the option
        inherit: bool, whether to inherit the value from the parent factory's `class Meta`
            when no value is provided
        checker: callable or None, an optional function used to detect invalid option
            values at declaration time
    """

    def __init__(self, name, value, inherit=..., checker=...) -> None: ...
    def apply(self, meta, base_meta): ...
    def __str__(self) -> str: ...

class FactoryOptions:
    def __init__(self) -> None: ...
    @property
    def declarations(self): ...
    def contribute_to_class(
        self, factory, meta=..., base_meta=..., base_factory=..., params=...
    ): ...
    def next_sequence(self):  # -> int:
        """Retrieve a new sequence ID.

        This will call, in order:
        - next_sequence from the base factory, if provided
        - _setup_next_sequence, if this is the 'toplevel' factory and the
            sequence counter wasn't initialized yet; then increase it.
        """
        ...
    def reset_sequence(self, value=..., force=...): ...
    def prepare_arguments(
        self, attributes
    ):  # -> tuple[tuple[Unknown, ...], dict[Unknown, Unknown]]:
        """Convert an attributes dict to a (args, kwargs) tuple."""
        ...
    def instantiate(self, step, args, kwargs): ...
    def use_postgeneration_results(self, step, instance, results): ...
    def get_model_class(self):
        """Extension point for loading model classes.

        This can be overridden in framework-specific subclasses to hook into
        existing model repositories, for instance.
        """
        ...
    def __str__(self) -> str: ...
    def __repr__(self): ...

class _Counter:
    """Simple, naive counter.

    Attributes:
        for_class (obj): the class this counter related to
        seq (int): the next value
    """

    def __init__(self, seq) -> None: ...
    def next(self): ...
    def reset(self, next_value=...): ...

class BaseFactory:
    """Factory base support for sequences, attributes and stubs."""

    UnknownStrategy = errors.UnknownStrategy
    UnsupportedStrategy = errors.UnsupportedStrategy
    def __new__(cls, *args, **kwargs):
        """Would be called if trying to instantiate the class."""
        ...
    _meta = ...
    _counter = ...
    @classmethod
    def reset_sequence(cls, value=..., force=...):  # -> None:
        """Reset the sequence counter.

        Args:
            value (int or None): the new 'next' sequence value; if None,
                recompute the next value from _setup_next_sequence().
            force (bool): whether to force-reset parent sequence counters
                in a factory inheritance chain.
        """
        ...
    @classmethod
    def build(cls, **kwargs):
        """Build an instance of the associated class, with overridden attrs."""
        ...
    @classmethod
    def build_batch(cls, size, **kwargs):  # -> list[Unknown]:
        """Build a batch of instances of the given class, with overridden attrs.

        Args:
            size (int): the number of instances to build

        Returns:
            object list: the built instances
        """
        ...
    @classmethod
    def create(cls, **kwargs):
        """Create an instance of the associated class, with overridden attrs."""
        ...
    @classmethod
    def create_batch(cls, size, **kwargs):  # -> list[Unknown]:
        """Create a batch of instances of the given class, with overridden attrs.

        Args:
            size (int): the number of instances to create

        Returns:
            object list: the created instances
        """
        ...
    @classmethod
    def stub(cls, **kwargs):
        """Retrieve a stub of the associated class, with overridden attrs.

        This will return an object whose attributes are those defined in this
        factory's declarations or in the extra kwargs.
        """
        ...
    @classmethod
    def stub_batch(cls, size, **kwargs):  # -> list[Unknown]:
        """Stub a batch of instances of the given class, with overridden attrs.

        Args:
            size (int): the number of instances to stub

        Returns:
            object list: the stubbed instances
        """
        ...
    @classmethod
    def generate(cls, strategy, **kwargs):  # -> Any:
        """Generate a new instance.

        The instance will be created with the given strategy (one of
        BUILD_STRATEGY, CREATE_STRATEGY, STUB_STRATEGY).

        Args:
            strategy (str): the strategy to use for generating the instance.

        Returns:
            object: the generated instance
        """
        ...
    @classmethod
    def generate_batch(cls, strategy, size, **kwargs):  # -> Any:
        """Generate a batch of instances.

        The instances will be created with the given strategy (one of
        BUILD_STRATEGY, CREATE_STRATEGY, STUB_STRATEGY).

        Args:
            strategy (str): the strategy to use for generating the instance.
            size (int): the number of instances to generate

        Returns:
            object list: the generated instances
        """
        ...
    @classmethod
    def simple_generate(cls, create, **kwargs):  # -> Any:
        """Generate a new instance.

        The instance will be either 'built' or 'created'.

        Args:
            create (bool): whether to 'build' or 'create' the instance.

        Returns:
            object: the generated instance
        """
        ...
    @classmethod
    def simple_generate_batch(cls, create, size, **kwargs):  # -> Any:
        """Generate a batch of instances.

        These instances will be either 'built' or 'created'.

        Args:
            size (int): the number of instances to generate
            create (bool): whether to 'build' or 'create' the instances.

        Returns:
            object list: the generated instances
        """
        ...

class Factory(BaseFactory, metaclass=FactoryMetaClass):
    """Factory base with build and create support.

    This class has the ability to support multiple ORMs by using custom creation
    functions.
    """

    class Meta(BaseMeta): ...

class StubObject:
    """A generic container."""

    def __init__(self, **kwargs) -> None: ...

class StubFactory(Factory):
    class Meta:
        strategy = ...
        model = StubObject
    @classmethod
    def build(cls, **kwargs): ...
    @classmethod
    def create(cls, **kwargs): ...

class BaseDictFactory(Factory):
    """Factory for dictionary-like classes."""

    class Meta:
        abstract = ...

class DictFactory(BaseDictFactory):
    class Meta:
        model = dict

class BaseListFactory(Factory):
    """Factory for list-like classes."""

    class Meta:
        abstract = ...

class ListFactory(BaseListFactory):
    class Meta:
        model = list

def use_strategy(new_strategy):  # -> (klass: Unknown) -> Unknown:
    """Force the use of a different strategy.

    This is an alternative to setting default_strategy in the class definition.
    """
    ...
