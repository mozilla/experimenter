"""
This type stub file was generated by pyright.
"""

from .utils.graph import GraphFormatter

"""A directed acyclic graph of reusable components."""
__all__ = ("Blueprint", "Step", "StartStopStep", "ConsumerStep")
RUN = ...
CLOSE = ...
TERMINATE = ...
logger = ...

class StepFormatter(GraphFormatter):
    """Graph formatter for :class:`Blueprint`."""

    blueprint_prefix = ...
    conditional_prefix = ...
    blueprint_scheme = ...
    def label(self, step): ...
    def node(self, obj, **attrs): ...
    def edge(self, a, b, **attrs): ...

class Blueprint:
    """Blueprint containing bootsteps that can be applied to objects.

    Arguments:
        steps Sequence[Union[str, Step]]: List of steps.
        name (str): Set explicit name for this blueprint.
        on_start (Callable): Optional callback applied after blueprint start.
        on_close (Callable): Optional callback applied before blueprint close.
        on_stopped (Callable): Optional callback applied after
            blueprint stopped.
    """

    GraphFormatter = StepFormatter
    name = ...
    state = ...
    started = ...
    default_steps = ...
    state_to_name = ...
    def __init__(
        self, steps=..., name=..., on_start=..., on_close=..., on_stopped=...
    ) -> None: ...
    def start(self, parent): ...
    def human_state(self): ...
    def info(self, parent): ...
    def close(self, parent): ...
    def restart(self, parent, method=..., description=..., propagate=...): ...
    def send_all(
        self, parent, method, description=..., reverse=..., propagate=..., args=...
    ): ...
    def stop(self, parent, close=..., terminate=...): ...
    def join(self, timeout=...): ...
    def apply(self, parent, **kwargs):  # -> Self@Blueprint:
        """Apply the steps in this blueprint to an object.

        This will apply the ``__init__`` and ``include`` methods
        of each step, with the object as argument::

            step = Step(obj)
            ...
            step.include(obj)

        For :class:`StartStopStep` the services created
        will also be added to the objects ``steps`` attribute.
        """
        ...
    def connect_with(self, other): ...
    def __getitem__(self, name): ...
    def claim_steps(self): ...
    def load_step(self, step): ...
    @property
    def alias(self): ...

class StepType(type):
    """Meta-class for steps."""

    name = ...
    requires = ...
    def __new__(cls, name, bases, attrs): ...
    def __str__(cls) -> str: ...
    def __repr__(cls): ...

class Step(metaclass=StepType):
    """A Bootstep.

    The :meth:`__init__` method is called when the step
    is bound to a parent object, and can as such be used
    to initialize attributes in the parent object at
    parent instantiation-time.
    """

    name = ...
    label = ...
    conditional = ...
    requires = ...
    last = ...
    enabled = ...
    def __init__(self, parent, **kwargs) -> None: ...
    def include_if(self, parent):  # -> bool:
        """Return true if bootstep should be included.

        You can define this as an optional predicate that decides whether
        this step should be created.
        """
        ...
    def instantiate(self, name, *args, **kwargs): ...
    def include(self, parent): ...
    def create(self, parent):  # -> None:
        """Create the step."""
        ...
    def __repr__(self): ...
    @property
    def alias(self): ...
    def info(self, obj): ...

class StartStopStep(Step):
    """Bootstep that must be started and stopped in order."""

    obj = ...
    def start(self, parent): ...
    def stop(self, parent): ...
    def close(self, parent): ...
    def terminate(self, parent): ...
    def include(self, parent): ...

class ConsumerStep(StartStopStep):
    """Bootstep that starts a message consumer."""

    requires = ...
    consumers = ...
    def get_consumers(self, channel): ...
    def start(self, c): ...
    def stop(self, c): ...
    def shutdown(self, c): ...
