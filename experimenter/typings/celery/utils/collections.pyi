"""
This type stub file was generated by pyright.
"""

from collections import OrderedDict as _OrderedDict
from collections.abc import Mapping, MutableMapping
from queue import Empty
from typing import Any, Dict, Iterable, List

"""Custom maps, sets, sequences, and other data structures."""
__all__ = (
    "AttributeDictMixin",
    "AttributeDict",
    "BufferMap",
    "ChainMap",
    "ConfigurationView",
    "DictAttribute",
    "Evictable",
    "LimitedSet",
    "Messagebuffer",
    "OrderedDict",
    "force_mapping",
    "lpmerge",
)
REPR_LIMITED_SET = ...

def force_mapping(m: Any) -> Mapping:
    """Wrap object into supporting the mapping interface if necessary."""
    ...

def lpmerge(L: Mapping, R: Mapping) -> Mapping:
    """In place left precedent dictionary merge.

    Keeps values from `L`, if the value in `R` is :const:`None`.
    """
    ...

class OrderedDict(_OrderedDict):
    """Dict where insertion order matters."""

    if nothasattr(_OrderedDict, "move_to_end"): ...

class AttributeDictMixin:
    """Mixin for Mapping interface that adds attribute access.

    I.e., `d.key -> d[key]`).
    """

    def __getattr__(self, k: str) -> Any:
        """`d.key -> d[key]`."""
        ...
    def __setattr__(self, key: str, value: Any) -> None:
        """`d[key] = value -> d.key = value`."""
        ...

class AttributeDict(dict, AttributeDictMixin):
    """Dict subclass with attribute access."""

    ...

class DictAttribute:
    """Dict interface to attributes.

    `obj[k] -> obj.k`
    `obj[k] = val -> obj.k = val`
    """

    obj = ...
    def __init__(self, obj: Any) -> None: ...
    def __getattr__(self, key: Any) -> Any: ...
    def __setattr__(self, key: Any, value: Any) -> None: ...
    def get(self, key: Any, default: Any = ...) -> Any: ...
    def setdefault(self, key: Any, default: Any = ...) -> None: ...
    def __getitem__(self, key: Any) -> Any: ...
    def __setitem__(self, key: Any, value: Any) -> Any: ...
    def __contains__(self, key: Any) -> bool: ...
    iterkeys = ...
    def __iter__(self) -> Iterable: ...
    iteritems = ...
    itervalues = ...
    items = ...
    keys = ...
    values = ...

class ChainMap(MutableMapping):
    """Key lookup on a sequence of maps."""

    key_t = ...
    changes = ...
    defaults = ...
    maps = ...
    _observers = ...
    def __init__(self, *maps: Mapping, **kwargs: Any) -> None: ...
    def add_defaults(self, d: Mapping) -> None: ...
    def pop(self, key: Any, *default: Any) -> Any: ...
    def __missing__(self, key: Any) -> Any: ...
    def __getitem__(self, key: Any) -> Any: ...
    def __setitem__(self, key: Any, value: Any) -> None: ...
    def __delitem__(self, key: Any) -> None: ...
    def clear(self) -> None: ...
    def get(self, key: Any, default: Any = ...) -> Any: ...
    def __len__(self) -> int: ...
    def __iter__(self): ...
    def __contains__(self, key: Any) -> bool: ...
    def __bool__(self) -> bool: ...
    __nonzero__ = ...
    def setdefault(self, key: Any, default: Any = ...) -> None: ...
    def update(self, *args: Any, **kwargs: Any) -> Any: ...
    def __repr__(self) -> str: ...
    @classmethod
    def fromkeys(cls: type, iterable: Iterable, *args: Any) -> ChainMap:
        """Create a ChainMap with a single dict created from the iterable."""
        ...
    def copy(self) -> ChainMap: ...
    __copy__ = ...
    iterkeys = ...
    iteritems = ...
    itervalues = ...
    def bind_to(self, callback): ...
    keys = ...
    items = ...
    values = ...

class ConfigurationView(ChainMap, AttributeDictMixin):
    """A view over an applications configuration dictionaries.

    Custom (but older) version of :class:`collections.ChainMap`.

    If the key does not exist in ``changes``, the ``defaults``
    dictionaries are consulted.

    Arguments:
        changes (Mapping): Map of configuration changes.
        defaults (List[Mapping]): List of dictionaries containing
            the default configuration.
    """

    def __init__(
        self,
        changes: Mapping,
        defaults: Mapping = ...,
        keys: List[str] = ...,
        prefix: str = ...,
    ) -> None: ...
    def __getitem__(self, key: str) -> Any: ...
    def __setitem__(self, key: str, value: Any) -> Any: ...
    def first(self, *keys: str) -> Any: ...
    def get(self, key: str, default: Any = ...) -> Any: ...
    def clear(self) -> None:
        """Remove all changes, but keep defaults."""
        ...
    def __contains__(self, key: str) -> bool: ...
    def swap_with(self, other: ConfigurationView) -> None: ...

class LimitedSet:
    """Kind-of Set (or priority queue) with limitations.

    Good for when you need to test for membership (`a in set`),
    but the set should not grow unbounded.

    ``maxlen`` is enforced at all times, so if the limit is reached
    we'll also remove non-expired items.

    You can also configure ``minlen``: this is the minimal residual size
    of the set.

    All arguments are optional, and no limits are enabled by default.

    Arguments:
        maxlen (int): Optional max number of items.
            Adding more items than ``maxlen`` will result in immediate
            removal of items sorted by oldest insertion time.

        expires (float): TTL for all items.
            Expired items are purged as keys are inserted.

        minlen (int): Minimal residual size of this set.
            .. versionadded:: 4.0

            Value must be less than ``maxlen`` if both are configured.

            Older expired items will be deleted, only after the set
            exceeds ``minlen`` number of items.

        data (Sequence): Initial data to initialize set with.
            Can be an iterable of ``(key, value)`` pairs,
            a dict (``{key: insertion_time}``), or another instance
            of :class:`LimitedSet`.

    Example:
        >>> s = LimitedSet(maxlen=50000, expires=3600, minlen=4000)
        >>> for i in range(60000):
        ...     s.add(i)
        ...     s.add(str(i))
        ...
        >>> 57000 in s  # last 50k inserted values are kept
        True
        >>> '10' in s  # '10' did expire and was purged from set.
        False
        >>> len(s)  # maxlen is reached
        50000
        >>> s.purge(now=time.monotonic() + 7200)  # clock + 2 hours
        >>> len(s)  # now only minlen items are cached
        4000
        >>>> 57000 in s  # even this item is gone now
        False
    """

    max_heap_percent_overload = ...
    def __init__(
        self,
        maxlen: int = ...,
        expires: float = ...,
        data: Mapping = ...,
        minlen: int = ...,
    ) -> None: ...
    def clear(self) -> None:
        """Clear all data, start from scratch again."""
        ...
    def add(self, item: Any, now: float = ...) -> None:
        """Add a new item, or reset the expiry time of an existing item."""
        ...
    def update(self, other: Iterable) -> None:
        """Update this set from other LimitedSet, dict or iterable."""
        ...
    def discard(self, item: Any) -> None: ...
    pop_value = ...
    def purge(self, now: float = ...) -> None:
        """Check oldest items and remove them if needed.

        Arguments:
            now (float): Time of purging -- by default right now.
                This can be useful for unit testing.
        """
        ...
    def pop(self, default: Any = ...) -> Any:
        """Remove and return the oldest item, or :const:`None` when empty."""
        ...
    def as_dict(self) -> Dict:
        """Whole set as serializable dictionary.

        Example:
            >>> s = LimitedSet(maxlen=200)
            >>> r = LimitedSet(maxlen=200)
            >>> for i in range(500):
            ...     s.add(i)
            ...
            >>> r.update(s.as_dict())
            >>> r == s
            True
        """
        ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    def __repr__(self) -> str: ...
    def __iter__(self) -> Iterable: ...
    def __len__(self) -> int: ...
    def __contains__(self, key: Any) -> bool: ...
    def __reduce__(self) -> Any: ...
    def __bool__(self) -> bool: ...
    __nonzero__ = ...

class Evictable:
    """Mixin for classes supporting the ``evict`` method."""

    Empty = Empty
    def evict(self) -> None:
        """Force evict until maxsize is enforced."""
        ...

class Messagebuffer(Evictable):
    """A buffer of pending messages."""

    Empty = Empty
    def __init__(
        self, maxsize: int, iterable: Iterable = ..., deque: Any = ...
    ) -> None: ...
    def put(self, item: Any) -> None: ...
    def extend(self, it: Iterable) -> None: ...
    def take(self, *default: Any) -> Any: ...
    def __repr__(self) -> str: ...
    def __iter__(self) -> Iterable: ...
    def __len__(self) -> int: ...
    def __contains__(self, item) -> bool: ...
    def __reversed__(self) -> Iterable: ...
    def __getitem__(self, index: Any) -> Any: ...

class BufferMap(OrderedDict, Evictable):
    """Map of buffers."""

    Buffer = Messagebuffer
    Empty = Empty
    maxsize = ...
    total = ...
    bufmaxsize = ...
    def __init__(
        self, maxsize: int, iterable: Iterable = ..., bufmaxsize: int = ...
    ) -> None: ...
    def put(self, key: Any, item: Any) -> None: ...
    def extend(self, key: Any, it: Iterable) -> None: ...
    def take(self, key: Any, *default: Any) -> Any: ...
    def __repr__(self) -> str: ...
