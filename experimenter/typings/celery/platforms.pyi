"""
This type stub file was generated by pyright.
"""

import os
import signal as _signal
from contextlib import contextmanager

"""Platforms.

Utilities dealing with platform specifics: signals, daemonization,
users, groups, and so on.
"""
_setproctitle = ...
resource = ...
pwd = ...
grp = ...
mputil = ...
__all__ = (
    "EX_OK",
    "EX_FAILURE",
    "EX_UNAVAILABLE",
    "EX_USAGE",
    "SYSTEM",
    "IS_macOS",
    "IS_WINDOWS",
    "SIGMAP",
    "pyimplementation",
    "LockFailed",
    "get_fdmax",
    "Pidfile",
    "create_pidlock",
    "close_open_fds",
    "DaemonContext",
    "detached",
    "parse_uid",
    "parse_gid",
    "setgroups",
    "initgroups",
    "setgid",
    "setuid",
    "maybe_drop_privileges",
    "signals",
    "signal_name",
    "set_process_title",
    "set_mp_process_title",
    "get_errno_name",
    "ignore_errno",
    "fd_by_path",
    "isatty",
)
EX_OK = ...
EX_FAILURE = ...
EX_UNAVAILABLE = ...
EX_USAGE = ...
EX_CANTCREAT = ...
SYSTEM = ...
IS_macOS = ...
IS_WINDOWS = ...
DAEMON_WORKDIR = ...
PIDFILE_FLAGS = ...
PIDFILE_MODE = ...
PIDLOCKED = ...
_range = ...
ROOT_DISALLOWED = ...
ROOT_DISCOURAGED = ...
ASSUMING_ROOT = ...
SIGNAMES = ...
SIGMAP = ...

def isatty(fh):  # -> None:
    """Return true if the process has a controlling terminal."""
    ...

def pyimplementation():  # -> str:
    """Return string identifying the current Python implementation."""
    ...

class LockFailed(Exception):
    """Raised if a PID lock can't be acquired."""

    ...

class Pidfile:
    """Pidfile.

    This is the type returned by :func:`create_pidlock`.

    See Also:
        Best practice is to not use this directly but rather use
        the :func:`create_pidlock` function instead:
        more convenient and also removes stale pidfiles (when
        the process holding the lock is no longer running).
    """

    path = ...
    def __init__(self, path) -> None: ...
    def acquire(self):  # -> Self@Pidfile:
        """Acquire lock."""
        ...
    __enter__ = ...
    def is_locked(self):  # -> bool:
        """Return true if the pid lock exists."""
        ...
    def release(self, *args):  # -> None:
        """Release lock."""
        ...
    __exit__ = ...
    def read_pid(self):  # -> int:
        """Read and return the current pid."""
        ...
    def remove(self):  # -> None:
        """Remove the lock."""
        ...
    def remove_if_stale(self):  # -> bool:
        """Remove the lock if the process isn't running.

        I.e. process does not respons to signal.
        """
        ...
    def write_pid(self): ...

PIDFile = Pidfile

def create_pidlock(pidfile):  # -> Pidfile:
    """Create and verify pidfile.

    If the pidfile already exists the program exits with an error message,
    however if the process it refers to isn't running anymore, the pidfile
    is deleted and the program continues.

    This function will automatically install an :mod:`atexit` handler
    to release the lock at exit, you can skip this by calling
    :func:`_create_pidlock` instead.

    Returns:
       Pidfile: used to manage the lock.

    Example:
        >>> pidlock = create_pidlock('/var/run/app.pid')
    """
    ...

def fd_by_path(paths):  # -> list[int]:
    """Return a list of file descriptors.

    This method returns list of file descriptors corresponding to
    file paths passed in paths variable.

    Arguments:
        paths: List[str]: List of file paths.

    Returns:
        List[int]: List of file descriptors.

    Example:
        >>> keep = fd_by_path(['/dev/urandom', '/my/precious/'])
    """
    ...

class DaemonContext:
    """Context manager daemonizing the process."""

    _is_open = ...
    def __init__(
        self,
        pidfile=...,
        workdir=...,
        umask=...,
        fake=...,
        after_chdir=...,
        after_forkers=...,
        **kwargs
    ) -> None: ...
    def redirect_to_null(self, fd): ...
    def open(self): ...
    __enter__ = ...
    def close(self, *args): ...
    __exit__ = ...

def detached(
    logfile=..., pidfile=..., uid=..., gid=..., umask=..., workdir=..., fake=..., **opts
):  # -> DaemonContext:
    """Detach the current process in the background (daemonize).

    Arguments:
        logfile (str): Optional log file.
            The ability to write to this file
            will be verified before the process is detached.
        pidfile (str): Optional pid file.
            The pidfile won't be created,
            as this is the responsibility of the child.  But the process will
            exit if the pid lock exists and the pid written is still running.
        uid (int, str): Optional user id or user name to change
            effective privileges to.
        gid (int, str): Optional group id or group name to change
            effective privileges to.
        umask (str, int): Optional umask that'll be effective in
            the child process.
        workdir (str): Optional new working directory.
        fake (bool): Don't actually detach, intended for debugging purposes.
        **opts (Any): Ignored.

    Example:
        >>> from celery.platforms import detached, create_pidlock
        >>> with detached(
        ...           logfile='/var/log/app.log',
        ...           pidfile='/var/run/app.pid',
        ...           uid='nobody'):
        ... # Now in detached child process with effective user set to nobody,
        ... # and we know that our logfile can be written to, and that
        ... # the pidfile isn't locked.
        ... pidlock = create_pidlock('/var/run/app.pid')
        ...
        ... # Run the program
        ... program.run(logfile='/var/log/app.log')
    """
    ...

def parse_uid(uid):  # -> int | Any:
    """Parse user id.

    Arguments:
        uid (str, int): Actual uid, or the username of a user.
    Returns:
        int: The actual uid.
    """
    ...

def parse_gid(gid):  # -> int | Any:
    """Parse group id.

    Arguments:
        gid (str, int): Actual gid, or the name of a group.
    Returns:
        int: The actual gid of the group.
    """
    ...

def setgroups(groups):  # -> None:
    """Set active groups from a list of group ids."""
    ...

def initgroups(uid, gid):  # -> None:
    """Init process group permissions.

    Compat version of :func:`os.initgroups` that was first
    added to Python 2.7.
    """
    ...

def setgid(gid):  # -> None:
    """Version of :func:`os.setgid` supporting group names."""
    ...

def setuid(uid):  # -> None:
    """Version of :func:`os.setuid` supporting usernames."""
    ...

def maybe_drop_privileges(uid=..., gid=...):  # -> None:
    """Change process privileges to new user/group.

    If UID and GID is specified, the real user/group is changed.

    If only UID is specified, the real user is changed, and the group is
    changed to the users primary group.

    If only GID is specified, only the group is changed.
    """
    ...

if hasattr(_signal, "setitimer"): ...
else: ...

class Signals:
    """Convenience interface to :mod:`signals`.

    If the requested signal isn't supported on the current platform,
    the operation will be ignored.

    Example:
        >>> from celery.platforms import signals

        >>> from proj.handlers import my_handler
        >>> signals['INT'] = my_handler

        >>> signals['INT']
        my_handler

        >>> signals.supported('INT')
        True

        >>> signals.signum('INT')
        2

        >>> signals.ignore('USR1')
        >>> signals['USR1'] == signals.ignored
        True

        >>> signals.reset('USR1')
        >>> signals['USR1'] == signals.default
        True

        >>> from proj.handlers import exit_handler, hup_handler
        >>> signals.update(INT=exit_handler,
        ...                TERM=exit_handler,
        ...                HUP=hup_handler)
    """

    ignored = ...
    default = ...
    def arm_alarm(self, seconds): ...
    def reset_alarm(self): ...
    def supported(self, name):  # -> bool:
        """Return true value if signal by ``name`` exists on this platform."""
        ...
    def signum(self, name):  # -> Integral | Any:
        """Get signal number by name."""
        ...
    def reset(self, *signal_names):  # -> None:
        """Reset signals to the default signal handler.

        Does nothing if the platform has no support for signals,
        or the specified signal in particular.
        """
        ...
    def ignore(self, *names):  # -> None:
        """Ignore signal using :const:`SIG_IGN`.

        Does nothing if the platform has no support for signals,
        or the specified signal in particular.
        """
        ...
    def __getitem__(self, name): ...
    def __setitem__(self, name, handler):  # -> None:
        """Install signal handler.

        Does nothing if the current platform has no support for signals,
        or the specified signal in particular.
        """
        ...
    def update(self, _d_=..., **sigmap):  # -> None:
        """Set signal handlers from a mapping."""
        ...

signals = ...
get_signal = ...
install_signal_handler = ...
reset_signal = ...
ignore_signal = ...

def signal_name(signum):  # -> str:
    """Return name of signal from signal number."""
    ...

def strargv(argv): ...
def set_pdeathsig(name):  # -> None:
    """Sends signal ``name`` to process when parent process terminates."""
    ...

def set_process_title(progname, info=...):  # -> str:
    """Set the :command:`ps` name for the currently running process.

    Only works if :pypi:`setproctitle` is installed.
    """
    ...

if os.environ.get("NOSETPS"):
    def set_mp_process_title(*a, **k):  # -> None:
        """Disabled feature."""
        ...

else:
    def set_mp_process_title(progname, info=..., hostname=...):  # -> str:
        """Set the :command:`ps` name from the current process name.

        Only works if :pypi:`setproctitle` is installed.
        """
        ...

def get_errno_name(n):  # -> Any:
    """Get errno for string (e.g., ``ENOENT``)."""
    ...

@contextmanager
def ignore_errno(*errnos, **kwargs):  # -> Generator[None, None, None]:
    """Context manager to ignore specific POSIX error codes.

    Takes a list of error codes to ignore: this can be either
    the name of the code, or the code integer itself::

        >>> with ignore_errno('ENOENT'):
        ...     with open('foo', 'r') as fh:
        ...         return fh.read()

        >>> with ignore_errno(errno.ENOENT, errno.EPERM):
        ...    pass

    Arguments:
        types (Tuple[Exception]): A tuple of exceptions to ignore
            (when the errno matches).  Defaults to :exc:`Exception`.
    """
    ...

def check_privileges(accept_content): ...
